# Pole - LLM 특화 프로그래밍 언어

> LLM을 활용한 차세대 프로그래밍 언어 시스템

## 🎯 프로젝트 소개

**Pole**은 사람의 의도를 자연어에 가깝게 표현하고, LLM이 이를 안전하고 검증 가능한 코드로 변환하는 프로그래밍 언어 시스템입니다.

### 핵심 아이디어
- 사람은 **무엇을(What)** 하고 싶은지만 작성
- LLM은 **어떻게(How)** 구현할지 결정
- 시스템이 안전성과 정확성을 **자동 검증**

### 현재 상태 (2025-10-19)
- ✅ Phase 0: 기획 및 문서화 완료
- ✅ Phase 1: 언어 설계 완료 (명세 언어, IR, 검증 시스템)
- ✅ Phase 2: 프로토타입 구현 완료 (파서, 변환기, 인터프리터, 타입 체커, CLI)
- ✅ Phase 3: 완성도 향상 (P0 + 계약 검증 완료)

**작동하는 프로토타입** - 명세 작성부터 실행까지 전체 파이프라인 구현 완료

---

## 🚀 설치 및 사용법

### 설치

```bash
git clone <repository-url>
cd pole
```

**의존성**: Python 3.11+ (외부 패키지 의존성 없음, OpenRouter API는 선택사항)

### 환경 설정

**옵션 1: NixOS / Nix 사용자 (권장)**

```bash
# direnv 사용 (자동 환경 설정)
direnv allow

# 또는 nix-shell 직접 사용
nix-shell

# pole 명령어가 자동으로 사용 가능
pole run examples/01-factorial.pole-ir factorial 5
```

**옵션 2: 일반 Python 환경**

```bash
# PYTHONPATH 설정 후 사용
export PYTHONPATH=src
alias pole="python -m pole.cli.main"
```

### 사용 예시

```bash
# 1. 명세 파일 검증 - 완전성 체크 및 불명확성 탐지
pole check examples/01-factorial.pole

# 2. IR 파일에서 함수 실행
pole run examples/01-factorial.pole-ir factorial 5
# 출력: Result: 120

# 3. IR 파일의 모든 테스트 자동 실행
pole test examples/01-factorial.pole-ir
# 출력: Test Report (통과율, 실패한 테스트 상세)

# 4. 명세에서 IR 생성 (LLM API 필요 - OpenRouter)
export OPENROUTER_API_KEY=your_key_here
pole build examples/01-factorial.pole --output output.pole-ir

# 5. 또는 Mock LLM으로 테스트 (API 없이)
pole build examples/01-factorial.pole --mock
```

### 예제 파일 보기

```bash
cat examples/01-factorial.pole       # 팩토리얼 (재귀, 패턴 매칭)
cat examples/02-fibonacci.pole       # 피보나치 (단순 재귀)
cat examples/03-user-validation.pole # 사용자 검증 (복잡한 제약조건)
cat examples/04-simple-math.pole     # 수학 연산 (abs, max, sum_to_n)
```

**실행 가능한 모든 예제:**
- `factorial(7)` → 5040
- `fibonacci(8)` → 21  
- `abs(-15)` → 15
- `max(42, 17)` → 42
- `sum_to_n(100)` → 5050
```

---

## 📐 시스템 아키텍처

```
[사람] 명세 언어 (.pole) - 자연어 친화, 의도 중심
    ↓ LLM 변환
[LLM] 구현 언어 (Pole IR) - 형식적, 타입 안전, 검증 가능
    ↓ 컴파일
[실행] 바이트코드/기계어
```

**두 개의 언어 레이어**:
1. **명세 언어** (Specification Language) - 사람이 작성하는 고수준 언어
2. **구현 언어** (Implementation Language / IR) - LLM이 생성하는 형식 언어

자세한 내용: [ARCHITECTURE.md](ARCHITECTURE.md)

---

## 📂 프로젝트 구조

```
pole/
├── src/pole/              # 소스 코드
│   ├── parser/           # 명세 언어 파서
│   ├── validator/        # 명세 검증기
│   ├── transformer/      # LLM 변환기 (명세 → IR)
│   ├── runtime/          # IR 인터프리터
│   ├── verifier/         # 타입 체커, 계약 검증, 테스트 실행기
│   ├── common/           # 공통 에러 시스템
│   └── cli/              # CLI 도구
├── tests/                # 테스트 코드
├── specs/                # 언어 사양 문서
│   ├── syntax-v0.md      # 명세 언어 문법
│   ├── ir-syntax.md      # IR 문법
│   ├── verification.md   # 검증 시스템
│   └── workflow.md       # LLM 변환 워크플로우
├── examples/             # 예제 프로그램
│   ├── *.pole            # 명세 언어 예제
│   └── *.pole-ir         # IR 예제
├── ARCHITECTURE.md       # 시스템 아키텍처
├── ROADMAP.md            # 개발 로드맵
├── DEVELOPMENT.md        # 개발 가이드
└── README.md             # 본 문서
```

---

## 🎯 주요 기능

### ✅ 완성된 기능

**전체 파이프라인**
- 명세 언어 (.pole) 파싱 및 검증
- LLM 기반 IR 변환 (OpenRouter API 지원)
- IR 파싱 및 타입 체킹
- IR 인터프리터 (재귀, 패턴 매칭 지원)
- 예제 기반 자동 테스트
- 런타임 계약 검증 (requires/ensures)

**CLI 도구**
- `pole check` - 명세 파일 검증 및 불명확성 탐지
- `pole build` - LLM으로 IR 생성 (--mock 옵션으로 API 없이 테스트 가능)
- `pole run` - IR 함수 실행
- `pole test` - IR 테스트 자동 실행

**품질 보증**
- 통합 에러 시스템 (소스 위치 추적, 코드 하이라이팅)
- 정적 타입 체킹 (타입 추론 및 검증)
- 계약 기반 검증 (precondition/postcondition)
- 높은 성능 (대부분 작업 < 1ms)

**테스트 커버리지**
- 9개 테스트 모듈, 모든 테스트 통과
- 파서, 검증기, 변환기, 인터프리터, 타입 체커, 계약 검증, 에러 시스템, 성능 벤치마크

### 📋 향후 작업 (Phase 3 P1/P2)

- IDE 통합 (LSP) - 문법 하이라이팅, 자동 완성, 에러 표시
- 대화형 명세 개선 도구 - 사용자와 대화하며 명세 정제
- 디버거 - 실행 추적 및 중단점
- 프로파일러 - 성능 분석
- 문서 생성기 - 명세에서 문서 자동 생성

---

## 🎯 명세 언어 조건 (사람 작성)

### 표현 자유도
- 자연어 문장 구조 허용
- 문법적 엄격성 최소화
- 순서 무관한 선언
- 중복 표현 허용
- 불완전한 명세 허용
- 점진적 구체화 지원
- 다양한 추상화 수준 혼재 가능
- 암묵적 컨텍스트 의존 가능

### 의도 표현
- "무엇을" 중심 표현
- "왜" 설명 가능
- 목적 명시적 선언
- 제약 조건 선언적 표현
- 우선순위 명시 가능
- 트레이드오프 표현 가능
- 품질 속성 선언
- 비기능 요구사항 표현

### 예시 기반
- 구체적 사례 제시
- 입출력 예제
- 경계 케이스 명시
- 반례 제공 가능
- 시나리오 서술
- 유즈케이스 설명
- 테스트 케이스 형태 명세

### 도메인 친화성
- 도메인 특화 용어 사용
- 전문 용어 허용
- 업계 관례 반영
- 비즈니스 로직 직접 표현
- 도메인 지식 암묵적 활용
- 메타포와 비유 사용

### 모호성 관리
- 의도적 모호성 허용
- LLM에 판단 위임
- 다중 해석 가능 명세
- 구현 자유도 제공
- 최적화 전략 위임
- 세부사항 생략 가능

### 진화 가능성
- 단계적 정제
- 버전별 차이 명시
- 변경 이유 설명
- 마이그레이션 경로
- 하위 호환성 요구
- 실험적 기능 표시

### 검증 기준
- 성공/실패 조건
- 성능 목표
- 리소스 제약
- 보안 요구사항
- 품질 기준
- 허용 오차 범위
- SLA 명시

---

## ⚙️ 구현 언어 조건 (LLM 생성)

### 형식성
- 모호성 완전 제거
- 결정론적 의미론
- 형식 의미론 정의
- 수학적 기초
- 조작적 의미론 명확
- 동작 완전 정의
- 부작용 명시적 표현

### 타입 시스템
- 정적 타입 강제
- 의존 타입 지원
- 선형 타입 시스템
- 세션 타입
- 효과 시스템
- 소유권 시스템
- 차용 규칙
- 생명주기 명시

### 안전성 보장
- 메모리 안전성 증명
- 타입 안전성 증명
- 버퍼 오버플로우 방지
- 널 포인터 방지
- 정수 오버플로우 검사
- 경계 검사 자동
- 데이터 레이스 방지
- 데드락 방지

### 검증 가능성
- 정적 분석 완전 지원
- 추상 해석 가능
- 기호 실행 가능
- 모델 체킹 지원
- 정리 증명 통합
- SMT 솔버 연동
- 계약 프로그래밍
- 사전/사후 조건

### 최적화 가능성
- 순수 함수 우선
- 불변성 기본
- 참조 투명성
- 부작용 격리
- 병렬화 자동 추론
- 벡터화 가능
- 인라인 최적화
- 데드 코드 제거

### 추적 가능성
- 명세로 역추적 가능
- 생성 근거 메타데이터
- 변환 단계 기록
- 최적화 이력
- 의사결정 로그
- 소스 위치 매핑
- 프로파일링 정보

### 구성 가능성
- 모듈 시스템 엄격
- 인터페이스 명확 분리
- 의존성 명시적
- 사이드 이펙트 격리
- 합성 가능한 추상화
- 독립적 컴파일
- 증분 빌드 지원

---

## 🔍 검증 시스템 조건

### 명세 준수
- 명세에서 테스트 자동 생성
- 속성 기반 테스트
- 계약 자동 검증
- 불변 조건 체크
- 전제/후속 조건 검증
- 상태 불변성 유지
- 타입 정확성

### 정확성 증명
- 형식 검증 자동화
- 정리 증명기 통합
- 모델 체킹
- 동등성 검증
- 종료성 증명
- 안전성 증명
- 활성성 증명

### 성능 검증
- 시간 복잡도 분석
- 공간 복잡도 분석
- 벤치마크 자동 실행
- 프로파일링 자동화
- 병목 지점 식별
- 리소스 사용 측정
- 성능 회귀 탐지

### 보안 검증
- 취약점 자동 스캔
- 정보 흐름 분석
- 권한 검증
- 입력 검증 확인
- 암호화 정책 준수
- 인증/인가 체크
- 감사 로그 검증

### 품질 보증
- 코드 커버리지 측정
- 브랜치 커버리지
- 변이 테스트
- 경계 값 테스트
- 스트레스 테스트
- 카오스 테스트
- 회귀 테스트

### 자동 수정
- 에러 자동 진단
- 수정 제안 생성
- 자동 리팩토링
- 최적화 자동 적용
- 타입 에러 수정
- 메모리 누수 수정
- 경쟁 조건 해결

---

## 🔄 변환 시스템 조건 (명세 → 구현)

### 의미 보존
- 의도 정확히 변환
- 의미론적 동등성
- 동작 일치성
- 부작용 보존/제거
- 성능 특성 유지
- 예외 동작 일치

### 완전성
- 모든 명세 항목 처리
- 누락 항목 탐지
- 모순 탐지
- 과명세 처리
- 부족 명세 보완
- 암묵적 요구사항 추론

### 최적성
- 효율적 구현 선택
- 알고리즘 최적 선택
- 자료구조 최적 선택
- 메모리 레이아웃 최적화
- 캐시 친화적 구현
- 병렬화 기회 활용

### 추론 능력
- 맥락 이해
- 도메인 지식 활용
- 일반 상식 적용
- 모범 사례 적용
- 안티패턴 회피
- 관용구 인식

### 다중 후보
- 여러 구현 생성
- 트레이드오프 분석
- 대안 평가
- 최적 선택 기준
- 사용자 선호 학습
- 컨텍스트 기반 선택

---

## 🎛️ 제어 인터페이스 조건

### 피드백 루프
- 검증 결과 해석
- 실패 원인 분석
- 명세 수정 제안
- 구현 대안 제시
- 트레이드오프 설명
- 인간 개입 최소화

### 대화형 정제
- 명세 불명확 시 질문
- 선택지 제시
- 예제 요청
- 제약 확인
- 우선순위 질의
- 점진적 명확화

### 설명 가능성
- 생성 근거 설명
- 의사결정 투명화
- 대안 비교 설명
- 트레이드오프 설명
- 성능 특성 설명
- 제약 충돌 설명

### 제어 가능성
- 생성 전략 선택
- 최적화 수준 조절
- 안전성 수준 선택
- 상세도 조절
- 스타일 가이드 적용
- 제약 조건 우선순위

---

## 📊 메타 시스템 조건

### 학습 능력
- 사용자 패턴 학습
- 도메인 지식 축적
- 오류 패턴 학습
- 선호 사항 학습
- 코드베이스 학습
- 팀 컨벤션 학습

### 진화 메커니즘
- 언어 기능 확장
- 도메인 DSL 생성
- 새 패턴 통합
- 라이브러리 업데이트
- 최적화 기법 추가
- 검증 규칙 확장

### 생태계 통합
- 기존 도구 체인 연동
- IDE 통합
- CI/CD 통합
- 버전 관리 통합
- 문서화 자동 생성
- 모니터링 통합

### 협업 지원
- 팀 공유 명세
- 변경 이력 추적
- 리뷰 프로세스
- 병합 충돌 해결
- 일관성 유지
- 지식 공유

---

## 🔐 신뢰성 조건

### 재현 가능성
- 동일 명세 → 동일 결과
- 버전 관리
- 의존성 고정
- 빌드 재현성
- 환경 독립성
- 시드 제어

### 감사 가능성
- 전체 프로세스 로깅
- 의사결정 기록
- 변경 이력 추적
- 컴플라이언스 체크
- 라이선스 검증
- 보안 감사

### 복구 가능성
- 실패 시 롤백
- 체크포인트 자동 생성
- 부분 실패 처리
- 그레이스풀 디그레이데이션
- 에러 격리
- 자동 복구 시도

### 확장성
- 대규모 프로젝트 지원
- 분산 처리
- 캐싱 전략
- 증분 처리
- 병렬 검증
- 리소스 효율성

---

## 💡 인간 중심 조건

### 인지 부하 최소화
- 단순한 명세 문법
- 최소한의 학습 곡선
- 직관적 개념
- 자연스러운 표현
- 기억 부담 감소
- 멘탈 모델 단순

### 오류 내성
- 오타 자동 수정
- 문법 오류 복구
- 의미 오류 추론
- 누락 자동 보완
- 모순 자동 해결
- 명확화 요청

### 점진적 개발
- 프로토타입 빠른 생성
- 단계적 구체화
- 부분 구현 실행
- 조기 검증
- 빠른 피드백
- 반복적 개선

### 접근성
- 비전문가 사용 가능
- 도메인 전문가 친화
- 다국어 지원
- 장애인 접근성
- 교육 자료 내장
- 튜토리얼 시스템

---

## 🎯 개발 우선순위

### P0 (필수)
- 명세 표현 자유도
- 형식 검증 완전성
- 안전성 보장
- 의미 보존 변환
- 자동 검증 시스템

### P1 (중요)
- 성능 검증
- 설명 가능성
- 학습 능력
- 점진적 개발
- 오류 내성

### P2 (선택)
- 대화형 정제
- 다중 후보 생성
- 분산 처리
- 생태계 통합
- 고급 최적화

---

## 🗺️ 로드맵

자세한 작업 목록과 우선순위는 [ROADMAP.md](ROADMAP.md) 참조

### Phase 0: 기획 및 문서화 ✅
- [x] 프로젝트 구조 정의
- [x] 아키텍처 문서 작성
- [x] 변환 워크플로우 정의
- [x] 개발 가이드라인 작성

### Phase 1: 언어 설계 ✅
- [x] 명세 언어 문법 정의
- [x] 구현 언어(IR) 설계
- [x] IR 문법 및 예제 작성
- [x] 검증 시스템 요구사항 정의

### Phase 2: 프로토타입 구현 ✅
- [x] 개발 환경 설정
- [x] 명세 언어 파서
- [x] 명세 검증기
- [x] LLM 변환기
- [x] IR 인터프리터
- [x] 예제 기반 테스트 실행기
- [x] 타입 체커
- [x] CLI 도구

### Phase 3: 완성도 향상 (P0 완료, P1/P2 일부 남음)
- [x] 에러 메시지 개선 (P0)
- [x] 성능 최적화 (P0)
- [x] 계약 검증 시스템 (P1)
- [ ] IDE 통합 (LSP) (P1)
- [ ] 대화형 명세 개선 도구 (P2)
- [ ] 디버거 (P2)
- [ ] 프로파일러 (P2)
- [ ] 문서 생성기 (P2)

---

## 📚 문서

**아키텍처 및 설계**
- [ARCHITECTURE.md](ARCHITECTURE.md) - 시스템 아키텍처 상세 설명
- [README.md](README.md) - 프로젝트 소개 및 설계 원칙 (본 문서)

**언어 명세**
- [specs/syntax-v0.md](specs/syntax-v0.md) - 명세 언어 문법 정의
- [specs/ir-syntax.md](specs/ir-syntax.md) - IR 문법 정의
- [specs/verification.md](specs/verification.md) - 검증 시스템 설계
- [specs/workflow.md](specs/workflow.md) - LLM 변환 워크플로우

**개발 문서**
- [ROADMAP.md](ROADMAP.md) - 개발 로드맵 및 우선순위 관리
- [DEVELOPMENT.md](DEVELOPMENT.md) - 개발 환경 설정 및 가이드
- [AGENTS.md](AGENTS.md) - 개발 가이드라인 (AI 에이전트용)

---

## 📄 라이선스

MIT License - See [LICENSE](LICENSE) file for details.

Copyright (c) 2025 Pole Project

---

## 설계 원칙 상세

아래 섹션들은 Pole 언어 시스템의 각 컴포넌트에 대한 상세 설계 요구사항입니다.
