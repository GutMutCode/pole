# Pole 개발 로드맵

> **Game Engine Vision**: Pole 기반 차세대 게임 엔진 개발
>
> Unity/Unreal을 대체하는 LLM 네이티브 게임 엔진

**이전 로드맵 (Phase 0-4 프로토타입)**: [ROADMAP-v1-prototype.md](ROADMAP-v1-prototype.md)

---

## 📊 전체 개요

### 프로젝트 목표

**Pole**: LLM을 활용한 차세대 게임 엔진
- 자연어 명세로 게임 로직 작성
- LLM이 안전하고 최적화된 코드 생성
- Unity/Unreal 수준의 기능 + LLM 차별화

### 타임라인 (7-10년)

```
Year 0-1   : Phase 0-4  언어 기초 (완료) ✅
Year 1-2.5 : Phase 5-6  컴파일러 & 시스템 프로그래밍
Year 2.5-5.5: Phase 7-8  게임 엔진 핵심 (렌더링, 물리, ECS)
Year 5.5-7 : Phase 9    에디터 & 도구
Year 7-10  : Phase 10   생태계 & 상용화
```

### 현재 위치

**2025-10-19**: Phase 4 완료 → **Phase 5 시작**

**완료된 것:**
- ✅ 명세 언어 설계 및 파서
- ✅ IR 설계 및 인터프리터
- ✅ LLM 변환 시스템 (OpenRouter)
- ✅ 타입 체커, 계약 검증
- ✅ CLI 도구 (check, build, run, test)

**다음 목표:**
- 🎯 네이티브 컴파일러 (LLVM)
- 🎯 고성능 런타임
- 🎯 게임 엔진 기초

---

## 우선순위 원칙

### Phase 우선순위

1. **현재 Phase 내 P0 작업 우선**
2. **Phase P0 완료 → P1 검토**
3. **Phase 전환은 P0 완료 후만 가능**

### 작업 분류

- **P0 (Critical)**: 해당 Phase 완료 필수
- **P1 (High)**: Phase 완료 후 추가 가치
- **P2 (Medium)**: 선택적 개선
- **P3 (Low)**: 나중에

### 단기 vs 장기

- **단기 (Phase 0-4)**: ✅ 완료 (프로토타입)
- **중기 (Phase 5-6)**: 🔨 진행 중 (2년, 컴파일러)
- **장기 (Phase 7-10)**: 📅 계획 중 (5-8년, 게임 엔진)

---

## Phase 0-4: 언어 기초 (완료) ✅

**기간:** 2025년 초 ~ 2025-10-19 (약 1년)

**목표:** 작동하는 프로토타입 완성

### 완료된 Phase

- ✅ **Phase 0**: 기획 및 문서화
- ✅ **Phase 1**: 언어 설계 (명세 언어, IR)
- ✅ **Phase 2**: 프로토타입 구현 (파서, 변환기, 인터프리터, CLI)
- ✅ **Phase 3**: 완성도 향상 (에러 시스템, 성능, 계약 검증)
- ✅ **Phase 4**: LLM 통합 개선 (Prompt 개선, IR 후처리)

### 주요 산출물

- 명세 언어 파서 (`src/pole/parser/`)
- IR 인터프리터 (`src/pole/runtime/`)
- LLM 변환기 (`src/pole/transformer/`)
- 타입 체커 (`src/pole/verifier/type_checker.py`)
- CLI 도구 (`src/pole/cli/main.py`)
- 9개 테스트 모듈 (모두 통과)

### 시스템 능력 (현재)

✅ **작동하는 것:**
- 명세 언어 → IR 변환 (LLM)
- IR 실행 (인터프리터)
- 타입 체킹, 계약 검증
- 예제 기반 자동 테스트
- 6개 예제 프로그램 실행

⚠️ **제한사항:**
- 인터프리터만 존재 (느림)
- I/O 시스템 없음
- 그래픽/오디오 없음
- 게임 엔진용으로는 부족

**상세 내용:** [ROADMAP-v1-prototype.md](ROADMAP-v1-prototype.md)

---

## Phase 5: 네이티브 컴파일러 & 고성능 런타임 (Year 1-2.5)

**기간:** 2025-10 ~ 2027-03 (1.5년)

**목표:** Pole IR → 네이티브 기계어 컴파일, 게임 엔진급 성능 달성

**현재 문제:**
- 인터프리터: 느림 (게임 엔진 불가능)
- 메모리 관리: 기본적인 GC 없음
- 동시성: 싱글 스레드만 지원

**Phase 5 목표:**
- ✅ 네이티브 실행 파일 생성
- ✅ 성능: 인터프리터 대비 100x 이상
- ✅ 메모리 안전성 보장
- ✅ 멀티스레드 지원

---

### P0 작업 (필수)

#### 5.1 **LLVM 백엔드 개발** ⭐ 최우선

**목표:** Pole IR → LLVM IR → 네이티브 기계어

**기간:** 6-9개월 (2025-10 ~ 2026-06)

**산출물:**
- `src/pole/compiler/llvm/` (신규)
  - `ir_to_llvm.py` - IR → LLVM IR 변환
  - `codegen.py` - 코드 생성
  - `optimization.py` - 최적화 패스
- `pole compile <file> --target x86_64-linux` CLI 명령어
- 실행 파일 생성 (`game.exe`, `game`)

**마일스톤:**
1. **M1: 기본 함수 컴파일** (3개월)
   - 간단한 함수 (factorial) 컴파일
   - 기본 타입 (Int, Bool) 지원
   - 산술 연산자
   - **검증:** `pole compile factorial.pole` → 실행 파일 생성

2. **M2: 제어 흐름** (2개월)
   - if-then-else
   - match 패턴 매칭
   - **검증:** is_even, max 예제 컴파일

3. **M3: 재귀 함수** (2개월)
   - 꼬리 재귀 최적화
   - 스택 오버플로우 방지
   - **검증:** fibonacci 컴파일, 성능 측정

4. **M4: 전체 예제 컴파일** (2개월)
   - 모든 examples/*.pole 컴파일 성공
   - 타입 체킹 통합
   - **검증:** 6개 예제 네이티브 실행

**성공 기준:**
- ✅ 컴파일 성공률: 100% (모든 예제)
- ✅ 성능: factorial(20) < 0.001ms (인터프리터: ~0.06ms)
- ✅ 정확성: 모든 테스트 통과

**기술 스택:**
- LLVM 17.0+ (안정 버전)
- Python llvmlite 또는 Rust llvm-sys
- 참고: Cranelift (백업 옵션)

**리스크:**
- **High**: LLVM 학습 곡선
- **완화:** 단계적 구현, 커뮤니티 지원
- **비상 계획:** C++ 트랜스파일러 (Pole IR → C++)

**선행 조건:** 없음

**의존성:**
- 5.2, 5.3, 5.4가 이 작업에 의존

---

#### 5.2 **메모리 관리 시스템**

**목표:** 자동 + 수동 메모리 관리, 누수 방지

**기간:** 4-6개월 (5.1 M2 이후 시작)

**산출물:**
- `specs/memory-model.md` - 메모리 모델 설계
- `src/pole/compiler/memory/` (신규)
  - `gc.py` - 가비지 컬렉션 (참조 카운팅)
  - `allocator.py` - 커스텀 할당자 (Arena, Pool)
- `@manual_memory`, `@heap_allocated` 어노테이션

**구현 내용:**

1. **참조 카운팅 (RC)**
   - 자동 증가/감소
   - 순환 참조 감지 (Weak references)
   - Zero-cost abstractions

2. **커스텀 할당자**
   - Arena allocator (프레임 단위 일괄 해제)
   - Pool allocator (작은 객체 재사용)
   - Stack allocator (임시 데이터)

3. **소유권 시스템** (Rust 스타일)
   ```pole
   type Resource<T>
     @owned  // 소유권 명시
   
   function transfer(res: Resource<Texture>) -> Resource<Texture>
     // 소유권 이동, 복사 없음
   ```

**마일스톤:**
1. **M1: RC 기본 구현** (2개월)
   - 참조 카운트 자동 관리
   - 메모리 해제 자동화

2. **M2: 순환 참조 감지** (1개월)
   - Weak references
   - 누수 검증 도구

3. **M3: Arena allocator** (1개월)
   - 프레임 단위 할당/해제
   - 게임 엔진 최적화

4. **M4: 메모리 프로파일러** (1개월)
   - 메모리 사용량 추적
   - 누수 자동 감지

**성공 기준:**
- ✅ 메모리 누수: 0개 (Valgrind 검증)
- ✅ 오버헤드: < 5% (RC)
- ✅ Arena allocator: 10x 빠른 할당

**선행 조건:** 5.1 M2 (컴파일러 기본 완성)

---

#### 5.3 **성능 최적화 시스템**

**목표:** 컴파일러 최적화 자동 적용

**기간:** 3-4개월 (5.1 M3 이후)

**산출물:**
- `@inline`, `@simd`, `@hot_path` 어노테이션
- LLVM 최적화 파이프라인 통합
- 성능 벤치마킹 도구

**구현 내용:**

1. **컴파일 타임 최적화**
   - 상수 폴딩
   - 데드 코드 제거
   - 함수 인라인
   - 루프 언롤링

2. **SIMD 벡터화**
   ```pole
   @simd
   function dot_product(a: Vec3, b: Vec3) -> float:
     a.x * b.x + a.y * b.y + a.z * b.z
   // 컴파일러가 SSE/AVX 명령어 생성
   ```

3. **LTO (Link-Time Optimization)**
   - 모듈 간 최적화
   - 전역 인라인

**마일스톤:**
1. **M1: 기본 최적화** (1개월)
   - -O2 수준
2. **M2: SIMD 지원** (1개월)
3. **M3: LTO** (1개월)

**성공 기준:**
- ✅ 성능: Python 대비 10-100x
- ✅ SIMD: 벡터 연산 4x 빠름

**선행 조건:** 5.1 M3

---

#### 5.4 **동시성 & 병렬 처리**

**목표:** 멀티스레드 안전성, 병렬 실행

**기간:** 4-5개월 (5.2 이후)

**산출물:**
- `@async`, `@parallel` 어노테이션
- Thread-safe 타입 시스템
- 데이터 레이스 컴파일 타임 검증

**구현 내용:**

1. **비동기 프로그래밍**
   ```pole
   @async
   function load_asset(path: string) -> Future<Asset>:
     // 비동기 로딩
   ```

2. **병렬 처리**
   ```pole
   @parallel
   function update_particles(particles: Array<Particle>):
     // 자동 병렬화
   ```

3. **동기화 기본 요소**
   - Mutex, RwLock
   - Atomic 연산
   - Channel (메시지 전달)

**마일스톤:**
1. **M1: 스레드 안전성 분석** (2개월)
2. **M2: async/await** (2개월)
3. **M3: 병렬 for** (1개월)

**성공 기준:**
- ✅ 데이터 레이스: 0개 (컴파일 타임 검증)
- ✅ 병렬 성능: 4코어에서 3.5x

**선행 조건:** 5.1 M4, 5.2 M2

---

### P1 작업 (중요)

#### 5.5 **JIT 컴파일러** (선택적)
- **기간:** 3-4개월
- **목표:** 런타임 최적화
- **우선순위:** P1 (Phase 5 P0 완료 후 검토)

#### 5.6 **크로스 컴파일** (선택적)
- **기간:** 2-3개월
- **목표:** Windows, macOS, Linux 지원
- **우선순위:** P1

---

### Phase 5 완료 기준

**필수 (P0):**
- ✅ 네이티브 컴파일: 모든 예제 성공
- ✅ 성능: factorial(20) < 0.001ms (100x 개선)
- ✅ 메모리 안전성: 누수 0개
- ✅ 멀티스레드: 데이터 레이스 0개

**데모:**
- 네이티브 실행 파일 생성
- 성능 벤치마크 (vs Python, vs 인터프리터)
- YouTube 영상 공개

**Phase 5 → Phase 6 전환 조건:**
- 위 4가지 완료 기준 모두 충족

---

## Phase 6: 시스템 프로그래밍 기능 (Year 2.5-3.5)

**기간:** 2027-03 ~ 2028-03 (1년)

**목표:** C/C++ 라이브러리 연동, 저수준 제어, 대규모 프로젝트 지원

**Phase 6 목표:**
- ✅ SDL2, OpenGL 호출 가능
- ✅ 포인터 직접 조작 (unsafe)
- ✅ 모듈 시스템으로 게임 엔진 구조화

---

### P0 작업 (필수)

#### 6.1 **FFI (Foreign Function Interface)**

**목표:** C/C++ 라이브러리 호출

**기간:** 3-4개월

**산출물:**
- `@ffi`, `@extern` 어노테이션
- `pole bindgen <header.h>` 자동 바인딩 생성
- SDL2, OpenGL 바인딩

**구현 내용:**

1. **C ABI 호환성**
   ```pole
   @ffi("SDL2")
   @extern("SDL_Init")
   function sdl_init(flags: u32) -> i32
   
   @ffi("OpenGL")
   @extern("glClear")
   function gl_clear(mask: u32) -> Unit
   ```

2. **바인딩 자동 생성**
   ```bash
   pole bindgen SDL2.h > sdl2_bindings.pole
   pole bindgen vulkan/vulkan.h > vulkan_bindings.pole
   ```

3. **안전성 래퍼**
   ```pole
   @safe_ffi
   function load_texture(path: string) -> Result<Texture, Error>:
     underlying: SDL_LoadBMP(path)
     // 자동 에러 체크, 메모리 관리
   ```

**마일스톤:**
1. **M1: 간단한 C 함수 호출** (1개월)
2. **M2: 구조체 전달** (1개월)
3. **M3: 콜백 지원** (1개월)
4. **M4: SDL2로 윈도우 띄우기** (1개월)

**성공 기준:**
- ✅ SDL2 윈도우 생성 성공
- ✅ OpenGL 삼각형 렌더링

**선행 조건:** Phase 5 완료

---

#### 6.2 **저수준 메모리 제어**

**목표:** 포인터, unsafe 블록, 메모리 레이아웃 제어

**기간:** 2-3개월

**산출물:**
- `@repr(C)`, `@packed`, `@align(N)` 어노테이션
- `*const T`, `*mut T` 포인터 타입
- `unsafe { }` 블록

**구현 내용:**

```pole
@repr(C)  // C 구조체 호환
type Vertex:
  fields:
    - position: Vec3  // 12 bytes
    - normal: Vec3    // 12 bytes
    - uv: Vec2        // 8 bytes
  @align(16)  // 16바이트 정렬 (SIMD)

@unsafe
function write_gpu_buffer(ptr: *mut u8, data: Array<float>):
  // 직접 메모리 쓰기
```

**마일스톤:**
1. **M1: 메모리 레이아웃 제어** (1개월)
2. **M2: 포인터 타입** (1개월)
3. **M3: Unsafe 블록** (1개월)

**성공 기준:**
- ✅ GPU 버퍼 직접 쓰기 가능
- ✅ Zero-copy 데이터 전달

**선행 조건:** 6.1 M2

---

#### 6.3 **모듈 & 패키지 시스템**

**목표:** 대규모 게임 엔진 프로젝트 관리

**기간:** 4-5개월

**산출물:**
- `pole.toml` 프로젝트 설정
- `pole add <package>` 패키지 관리자
- 증분 컴파일
- 중앙 패키지 레지스트리 (pole.dev)

**구현 내용:**

```pole
// pole.toml
[package]
name = "my_game_engine"
version = "0.1.0"

[dependencies]
pole_math = "1.0"
pole_graphics = "2.0"
pole_physics = "1.5"

// 모듈 정의
module graphics:
  public:
    type Renderer
    function create_renderer() -> Renderer
  private:
    type InternalState
```

```bash
pole new my_game
pole add pole_graphics@2.0
pole build --release
pole publish
```

**마일스톤:**
1. **M1: 모듈 시스템** (2개월)
2. **M2: 패키지 관리자** (2개월)
3. **M3: 증분 컴파일** (1개월)

**성공 기준:**
- ✅ 1000+ 파일 프로젝트 관리 가능
- ✅ 증분 컴파일: < 5초

**선행 조건:** Phase 5 완료

---

### P1 작업 (중요)

#### 6.4 **매크로 & 메타프로그래밍**
- **기간:** 3-4개월
- **목표:** 코드 생성 자동화
- **우선순위:** P1

---

### Phase 6 완료 기준

**필수 (P0):**
- ✅ SDL2 윈도우 + OpenGL 삼각형
- ✅ 포인터로 GPU 버퍼 조작
- ✅ 모듈 시스템으로 대규모 프로젝트

**데모:**
- SDL2 + OpenGL 데모 프로그램
- 회전하는 삼각형 렌더링

**Phase 6 → Phase 7 전환:**
- P0 완료 + 게임 엔진 개발 준비 완료

---

## Phase 7: 게임 엔진 기초 (Year 3.5-5)

**기간:** 2028-03 ~ 2029-09 (1.5년)

**목표:** 렌더링, ECS, 물리, 에셋 시스템

**Phase 7 목표:**
- ✅ 3D 게임 데모 제작 가능
- ✅ 60 FPS (1000+ 오브젝트)
- ✅ 물리 시뮬레이션 안정적

---

### P0 작업 (필수)

#### 7.1 **그래픽 렌더링 추상화**

**기간:** 6-8개월

**산출물:**
- `pole_graphics` 표준 라이브러리
- Vulkan/OpenGL/Metal 백엔드
- 셰이더 컴파일러 (Pole → SPIR-V)

**마일스톤:**
1. **M1: 2D 스프라이트** (2개월)
2. **M2: 3D 메시** (2개월)
3. **M3: 기본 라이팅** (2개월)
4. **M4: 텍스처 매핑** (2개월)

**성공 기준:**
- ✅ 3D 모델 렌더링
- ✅ 60 FPS (1000 메시)

---

#### 7.2 **ECS (Entity Component System)**

**기간:** 4-6개월

**산출물:**
- `pole_ecs` 라이브러리
- `@component`, `@system` 매크로

**마일스톤:**
1. **M1: 컴포넌트 저장** (2개월)
2. **M2: 쿼리 시스템** (1개월)
3. **M3: 시스템 스케줄링** (1개월)
4. **M4: 성능 최적화** (1개월)

**성공 기준:**
- ✅ 10,000 엔티티 60 FPS

---

#### 7.3 **물리 엔진 통합**

**기간:** 3-4개월

**산출물:**
- `pole_physics` 라이브러리
- 충돌 감지, Rigidbody

**성공 기준:**
- ✅ 1000 오브젝트 물리 시뮬레이션

---

#### 7.4 **에셋 시스템**

**기간:** 3-4개월

**산출물:**
- 비동기 로딩
- 에셋 임포터 (PNG, OBJ, GLTF)

---

#### 7.5 **입력 시스템**

**기간:** 2개월

**산출물:**
- 키보드/마우스/게임패드

---

### P1 작업

#### 7.6 **오디오 시스템**
- **기간:** 2-3개월

---

### Phase 7 완료 기준

**필수 (P0):**
- ✅ 간단한 3D FPS 게임 데모
- ✅ 60 FPS 유지
- ✅ 물리 시뮬레이션 작동

**데모:**
- 3D FPS 게임 (YouTube)
- 오픈소스 공개

---

## Phase 8: 게임 엔진 고급 (Year 5-6.5)

**기간:** 2029-09 ~ 2031-03 (1.5년)

**목표:** PBR 렌더링, 애니메이션, UI, 네트워킹

### P0 작업

#### 8.1 **고급 렌더링**
- **기간:** 6-8개월
- PBR, 그림자, 포스트 프로세싱

#### 8.2 **애니메이션 시스템**
- **기간:** 4-5개월
- 스켈레탈, 블렌딩

#### 8.3 **UI 시스템**
- **기간:** 3-4개월
- 버튼, 텍스트, 레이아웃

### P1 작업

#### 8.4 **네트워킹**
- **기간:** 4-6개월

#### 8.5 **스크립팅**
- **기간:** 2-3개월

### Phase 8 완료 기준

- ✅ AAA급 그래픽 품질
- ✅ 캐릭터 애니메이션
- ✅ 완전한 UI

---

## Phase 9: 에디터 & 도구 (Year 6.5-8)

**기간:** 2031-03 ~ 2032-09 (1.5년)

**목표:** Unity 수준 비주얼 에디터

### P0 작업

#### 9.1 **비주얼 에디터**
- **기간:** 8-10개월
- 씬 편집, 인스펙터, 에셋 브라우저

#### 9.2 **프로파일러 & 디버거**
- **기간:** 4-5개월

#### 9.3 **빌드 시스템**
- **기간:** 3-4개월
- 멀티 플랫폼

### P1 작업

#### 9.4 **비주얼 스크립팅**
- **기간:** 4-6개월

### Phase 9 완료 기준

- ✅ 에디터로 게임 제작 가능
- ✅ Windows, macOS, Linux 빌드

---

## Phase 10: 생태계 & 최적화 (Year 8-10)

**기간:** 2032-09 ~ 2035 (2-3년)

**목표:** 커뮤니티, 플러그인, 상용화

### P0 작업

#### 10.1 **플러그인 시스템**
- **기간:** 3-4개월

#### 10.2 **고급 최적화**
- **기간:** 6-8개월

### P1 작업

#### 10.3 **클라우드 & 서비스**
- **기간:** 4-6개월

#### 10.4 **문서 & 학습 자료**
- **기간:** 지속적

### Phase 10 완료 기준

- ✅ 첫 상업 게임 출시
- ✅ 커뮤니티 1000+ 개발자
- ✅ 플러그인 마켓플레이스

---

## 주요 마일스톤

### Milestone 1: 네이티브 컴파일 (Year 2)
- ✅ Pole → 실행 파일
- ✅ 성능: 100x 개선
- **데모:** factorial, fibonacci

### Milestone 2: 3D 게임 데모 (Year 4)
- ✅ 간단한 FPS
- ✅ 60 FPS, 1000+ 오브젝트
- **데모:** YouTube 공개

### Milestone 3: 에디터 알파 (Year 7)
- ✅ 비주얼 에디터
- ✅ 샘플 게임 5개
- **데모:** Steam Early Access

### Milestone 4: 상업 게임 (Year 10)
- ✅ Pole로 개발한 게임 출시
- ✅ 커뮤니티 1000+
- **데모:** 게임 어워드

---

## 성공 지표

### Year 2 (Phase 5)
- [ ] 네이티브 컴파일: 100%
- [ ] 성능: 100x vs 인터프리터
- [ ] 메모리 안전성: 0 누수

### Year 4 (Phase 7)
- [ ] 3D 렌더링: 60 FPS (1000 오브젝트)
- [ ] 물리: 안정적
- [ ] 개발자: 100+

### Year 7 (Phase 9)
- [ ] 에디터 완성도: 70%
- [ ] 샘플 게임: 10개
- [ ] 사용자: 500+

### Year 10 (Phase 10)
- [ ] 상업 게임: 1개 이상
- [ ] 커뮤니티: 1000+
- [ ] 플러그인: 50+

---

## 리스크 관리

### 기술적 리스크

#### High Risk

1. **LLVM 통합 복잡도** (Phase 5.1)
   - **완화:** 단계적 구현, 커뮤니티 지원
   - **비상 계획:** Cranelift 또는 C++ 트랜스파일러

2. **성능 목표 미달** (Phase 7)
   - **완화:** 조기 벤치마킹, 프로파일링
   - **비상 계획:** 네이티브 플러그인 허용

3. **에디터 복잡도** (Phase 9)
   - **완화:** Bevy, Godot 참고
   - **비상 계획:** CLI 도구 강화

#### Medium Risk

1. **FFI 안정성** (Phase 6.1)
2. **크로스 플랫폼** (Phase 9.3)

---

## 팀 & 리소스 계획

### 팀 규모

#### Year 1-2 (Phase 5)
- 컴파일러 엔지니어: 2명
- 런타임 엔지니어: 1명
- **총:** 3명

#### Year 3-4 (Phase 6-7)
- 컴파일러: 2명
- 그래픽: 2명
- 게임플레이: 2명
- QA: 1명
- **총:** 7명

#### Year 5-7 (Phase 8-9)
- 코어: 3명
- 그래픽/애니메이션: 3명
- 에디터: 4명
- 도구: 2명
- QA: 2명
- **총:** 14명

#### Year 8-10 (Phase 10)
- 전체 팀: 20-30명

### 예산 (연간)

- Year 1-2: $400K-600K
- Year 3-4: $1M-1.5M
- Year 5-7: $2M-3M
- Year 8-10: $3M-5M

**총 예상 비용:** $15-25M (10년)

---

## 현재 최우선 작업

**현재 Phase:** Phase 5 (네이티브 컴파일러)

**다음 작업:** ⭐ **5.1 LLVM 백엔드 개발 (M1)**

**작업 내용:**
1. LLVM 학습 (튜토리얼, 문서)
2. 간단한 함수 컴파일 프로토타입
3. factorial 예제 네이티브 실행

**예상 기간:** 3개월

**시작일:** 2025-10-20

---

## 변경 이력

- **2025-10-19**: 게임 엔진 비전으로 대폭 수정
  - Phase 5-10 추가 (7-10년 로드맵)
  - Phase 0-4 완료 선언
  - 기존 로드맵 → ROADMAP-v1-prototype.md 백업
- **2025-10-19**: Phase 4.4 완료 (IR 후처리 자동화)
- **2025-10-19**: Phase 4.3 완료 (LLM Prompt 개선)
- 이전 변경 이력: [ROADMAP-v1-prototype.md](ROADMAP-v1-prototype.md)
