# Pole 아키텍처

## 전체 파이프라인

```
┌─────────────────────────────────────────────────────────────┐
│                    Pole Language System                     │
└─────────────────────────────────────────────────────────────┘

[사람이 작성]
    ↓
┌──────────────────────┐
│  명세 언어 (Spec)    │  .pole 파일
│  - 자연어 친화적     │  예: function factorial: ...
│  - 의도 중심 표현    │
│  - 모호성 허용       │
└──────────────────────┘
    ↓
[LLM 변환 시스템]
    ↓
┌──────────────────────┐
│  구현 언어 (IR)      │  Pole IR (우리가 설계할 언어)
│  - 형식 의미론       │  예: func factorial(n: Nat): Nat { ... }
│  - 타입 안전성       │
│  - 검증 가능         │
└──────────────────────┘
    ↓
[컴파일러/인터프리터]
    ↓
┌──────────────────────┐
│  실행 코드           │  바이트코드/기계어/LLVM IR
│  - 최적화            │
│  - 플랫폼 종속       │
└──────────────────────┘
```

## 용어 정의

### 명세 언어 (Specification Language)
- **작성자**: 사람 (프로그래머, 도메인 전문가)
- **파일 확장자**: `.pole`
- **특징**: 자연어에 가까움, 의도 표현, 모호성 허용
- **예제**: `examples/01-factorial.pole`
- **문법**: `specs/syntax-v0.md`

### 구현 언어 (Implementation Language / Pole IR)
- **생성자**: LLM (변환 시스템)
- **파일 확장자**: `.pole-ir` (가칭)
- **특징**: 형식적, 타입 안전, 검증 가능, 모호성 없음
- **목적**: 명세의 의도를 정확하게 실행 가능한 형태로 변환
- **설계 문서**: `specs/implementation-lang.md` (예정)

### 실행 코드 (Executable Code)
- **생성자**: 컴파일러
- **형태**: 기계어, 바이트코드, LLVM IR 등
- **목적**: 실제 하드웨어에서 실행

## 핵심 개념

### Pole은 "하나의 언어"가 아닌 "언어 시스템"
- 명세 언어와 구현 언어는 **같은 Pole 생태계의 다른 레이어**
- 둘 다 우리가 설계하는 대상
- 기존 언어(Rust, Python 등)로 컴파일하는 것이 **아님**

### LLM의 역할

LLM은 단순한 변환기가 아니라, **명세 검증 → 변환 → 검증**의 전체 파이프라인을 담당합니다.

#### 1. 명세 분석 및 검증 단계 (변환 전)
**목적**: 불명확하거나 불완전한 명세를 사전에 탐지

- **불명확성 탐지**
  - 모호한 표현 식별 (예: "빠르게", "적절히" 등이 구체적 기준 없이 사용)
  - 여러 해석이 가능한 제약 조건
  - 충돌하는 요구사항
  
- **누락 정보 식별**
  - 필수 입력/출력 타입 미정의
  - 에러 처리 방식 누락
  - 경계 조건 미명시
  - 성능 요구사항 부재
  
- **모순 탐지**
  - 서로 충돌하는 제약 조건
  - 예제와 명세의 불일치
  - 불가능한 요구사항
  
- **명확화 질문 생성**
  - 사용자에게 구체적인 질문 제시
  - 선택지 제공 (트레이드오프 설명)
  - 예제 요청

**출력**: 명확화가 필요한 항목 리스트 또는 변환 진행 승인

#### 2. 변환 단계
**목적**: 검증된 명세를 형식적인 구현 언어로 변환

- 명세 언어 → 구현 언어 변환
- "의도 파악" + "정확한 코드 생성"
- 여러 구현 후보 생성 가능
- 각 후보의 트레이드오프 분석

#### 3. 검증 및 피드백 단계
**목적**: 생성된 코드가 명세를 만족하는지 확인

- 생성된 IR이 명세의 모든 제약 만족하는지 검증
- 예제 입출력 테스트
- 타입 안전성 검증
- 문제 발견 시 수정 또는 재질문

### 왜 두 레이어로 분리?
1. **인간 친화성**: 명세 언어는 쓰기 쉬워야 함
2. **기계 검증성**: 구현 언어는 검증 가능해야 함
3. **LLM 활용**: 두 세계를 LLM이 연결

## 프로젝트 구조

```
pole/
├── specs/
│   ├── syntax-v0.md              # 명세 언어 문법
│   └── implementation-lang.md     # 구현 언어 설계 (예정)
├── examples/
│   ├── *.pole                     # 명세 언어 예제
│   └── *.pole-ir                  # 구현 언어 예제 (예정)
├── src/
│   ├── transformer/               # LLM 기반 변환기 (예정)
│   ├── compiler/                  # IR 컴파일러 (예정)
│   └── verifier/                  # 검증 시스템 (예정)
└── README.md                      # 설계 원칙 및 조건
```

## 개발 단계

### Phase 1: 설계 (현재)
- [x] 명세 언어 문법 정의
- [ ] 구현 언어 설계
- [ ] 검증 시스템 요구사항

### Phase 2: 프로토타입
- [ ] 간단한 LLM 변환기
- [ ] 기본 인터프리터
- [ ] 예제 검증

### Phase 3: 완성도
- [ ] 타입 체커
- [ ] 형식 검증기
- [ ] 최적화

## FAQ

### Q: 기존 언어(Rust, OCaml)를 타겟으로 하지 않나요?
**A**: 아닙니다. Pole IR을 직접 설계합니다. 다만 최종 실행 단계에서 LLVM IR 등을 활용할 수는 있습니다.

### Q: LLM이 Rust 코드를 생성하는 건가요?
**A**: 아닙니다. LLM은 Pole IR을 생성합니다. Pole IR은 우리가 설계하는 형식 언어입니다.

### Q: 왜 직접 기계어를 만들지 않나요?
**A**: 명세 언어(.pole)와 기계어는 추상화 수준 차이가 너무 큽니다. IR이 중간 다리 역할을 합니다.
